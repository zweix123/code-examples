+ Ref：
  + [wiki](https://en.wikipedia.org/wiki/Cache_replacement_policies)

+ 把缓存看作一个键值对
+ 下面使用的队列并不是严格的Queue数据结构，而是一种方便表述的线性表

# Random

# Queue Based

## FIFO
顾名思义

# Recency Based

## LRU

+ 描述：队列，有长度上限，对缓存值，将其放在队首（如果之前不在则插入在队首，如果在则“移动”到队首），当队列达到上限时evict队尾元素
+ 实现：肯定不能使用裸的队列实现，使用哈希表和双向链表实现，哈希表维护键，其值是链表节点指针，然后拿着这个指针来实现直接移动到头部。当evict时，从队列中去掉队尾是容易的，但是怎么更新哈希表呢？所以需要链表节点中也要维护键。

# Frequency Based

## LFU

+ 描述：类似LRU，但是此时在队列首的不是最近使用的，而是在进入缓存后使用次数最多的。
+ 实现：在LRU的基础上，再加一个哈希表，该哈希表的键是频率，值是一个双向链表（原本维护键和链表节点的哈希表维护的各个节点则不一定在同一个双向链表上了）。此时算法比较自然。

    但还有两个问题

    + 如果有多个键值对的使用频率相同呢？按照LRU淘汰，此时在上面的结构中实现非常自然
    + 当缓存满了需要evict时，怎么找到使用频率最低的那一个双向队列？我个人的做法是：一个变量维护最小频率，当最小频率对应的双向链表为空时，自增1，同时每次有新的freq时对其取min。我无法证明，但通过测试。

# Other

## LRU-k

+ 一种描述：仍然类比LRU的队列，添加一个history list，缓存的值首先进入history list，在其中出现k次后，再进入正式的缓存队列。则普通的LRU相当于LRU-1，即先进入history list，但是立刻就符合进入缓存队列的要求了，于是直接放入缓存队列。
  + history list的大小也是有限制的。需不需要用户指定？本身的淘汰算法使用什么？

+ 另一种描述：将不足k个的缓存值和达到k个的缓存值放在同一个队列中。淘汰时优先淘汰不足k个的。两个内部都使用FIFO（选择最早的时间）淘汰。
