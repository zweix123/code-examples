+ Ref：
  + [wiki](https://en.wikipedia.org/wiki/Cache_replacement_policies)

+ 把缓存看作一个键值对
+ 下面使用的队列并不是严格的Queue数据结构，而是一种方便表述的线性表

# Random

# Queue Based

## FIFO
顾名思义

# Recency Based

## LRU

+ 描述：队列，有长度上限，对缓存值，将其放在队首（如果之前不在则插入在队首，如果在则“移动”到队首），当队列达到上限时evict队尾元素
+ 实现：肯定不能使用裸的队列实现，使用哈希表和双向链表实现，哈希表维护键，其值是链表节点指针，然后拿着这个指针来实现直接移动到头部。当evict时，从队列中去掉队尾是容易的，但是怎么更新哈希表呢？所以需要链表节点中也要维护键。

# Frequency Based

## LFU

+ 描述：类似LRU，但是此时在队列首的不是最近使用的，而是在进入缓存后使用次数最多的。
+ 实现：在LRU的基础上，再加一个哈希表，该哈希表的键是频率，值是一个双向链表（原本维护键和链表节点的哈希表维护的各个节点则不一定在同一个双向链表上了）。此时算法比较自然。

    但还有两个问题

    + 如果有多个键值对的使用频率相同呢？按照LRU淘汰，此时在上面的结构中实现非常自然
    + 当缓存满了需要evict时，怎么找到使用频率最低的那一个双向队列？
