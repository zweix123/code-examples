开放寻址法哈希表相关问题

## 不会出现哈希冲突
直接定义布尔数组
insert: data[hash(value)] = true;
contain: return data[hash(value)];

## 会出现哈希冲突, 使用一次探测解决
insert: 循环找到空的位置, 对应位置插入值
contain: 对应位置有值不保证匹配,比较对应的值,直到找到或者遇到空位置(真的没有)
>我们发现如果哈希表插入慢, 查询会死循环, 所以需要对哈希表进行扩充, 暂不考虑

## 支持删除
>我们要保证一个值唯一的在表中
delete: 对应位置特殊标记, 此时data中有三种类型, 空, 特殊(即墓碑), 值
insert: 遇到空或者特殊标记都可以插入
contain: 遇到空不能停止. 应为可能下面的情况

                       x
hash : [a]   [a]  [a] [a]  [b]  [b]  [a]
value: [s1] [s2] [s3] [s4] [s5] [s6] [s7]

我们发现对于标记的地方，如果只是简单的置空，则后面再查哈希值为a时后空过去后面的a
所以删除时仅仅是标记, 同时检查时只有真的空才停止, 遇到墓碑继续找

## 对于扩容
哈希表认为时间复杂度是O(1)的嘛，我们发现如果扩容(无论用什么方法),
总是将一个插入到表中的元素重新插入到另一个表中,
这个均摊O(1)的时间复杂度是怎么来的呢?

对于扩容, 有两个常量, 装填因子(k)和扩容倍数(d),
即插入的值占哈希表大小的占比超过装填因子则进行扩容, 哈希表扩大扩容倍数大小

所以对于插入的n个元素,
其中
(d ^ 0        - 0)                 * k * n个元素会移动log_d(n) - 0次
(d ^ 1        - d ^ 0)             * k * n个元素会移动log_d(n) - 1次
(d ^ 2        - d ^ 1)             * k * n个元素会移动log_d(n) - 2次
(d ^ 3        - d ^ 2)             * k * n个元素会移动log_d(n) - 3次
...
(d ^ log_d(n) - d ^ (log_d(n) - 1))* k * n个元素会移动1           次

推导式确实是上面，但是具体怎么推导到最后的1的我确实不知道。

## 考虑下扩容
>一般来说，装填因子是3/4，扩容是一倍, 特别小的情况再讨论

其实反而容易, 自然实现

## 引入并发

普通的读写锁

# 测试

测试代码见项目下./test/test_stl_hash_table.cpp
> 直接跳转链接:
> https://github.com/zweix123/ACT/blob/main/test/test_stl_hash_table.cpp
